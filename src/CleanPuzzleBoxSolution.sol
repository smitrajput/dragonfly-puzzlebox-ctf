pragma solidity ^0.8.19;

import "./PuzzleBox.sol";
import "forge-std/Test.sol";


contract CleanPuzzleBoxSolution is Test {

    function solve(PuzzleBox _puzzle) external payable {
        // How close can you get to opening the box?
        bytes memory selectoors = hex"7159a6188fd66f250091905511551052925facb1000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000092b071e47000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000001000000000000000000000000416e59dacfdb5d457304115bbfb9089531d873b70000000000000000000000000000000000000000000000000000000000000003000000000000000000000000c817dd2a5daa8f790677e399170c92aabd044b570000000000000000000000000000000000000000000000000000000000000096000000000000000000000000000000000000000000000000000000000000004b58657dcfc8f549a7e4cb7e1c60d908cc05ceff53ad731e6ea0736edf7ffeea588dfb42d800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000041c8f549a7e4cb7e1c60d908cc05ceff53ad731e6ea0736edf7ffeea588dfb42d89da3468f3d897010503caed5c52689b959fbac09ff6879275a8279feffcc8a621b00000000000000000000000000000000000000000000000000000000000000";
        bytes memory helperCode = hex"60c060405273037eda3adb1198021a9b2e88c22b464fd38db3f373ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff16815250503373ffffffffffffffffffffffffffffffffffffffff1660a08173ffffffffffffffffffffffffffffffffffffffff168152505060805173ffffffffffffffffffffffffffffffffffffffff16637159a6186040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156100ca57600080fd5b505af11580156100de573d6000803e3d6000fd5b5050505073037eda3adb1198021a9b2e88c22b464fd38db3f373ffffffffffffffffffffffffffffffffffffffff1663deecedd463925facb160e01b60006040518363ffffffff1660e01b81526004016101399291906101c6565b600060405180830381600087803b15801561015357600080fd5b505af1158015610167573d6000803e3d6000fd5b505050506101ef565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6101a581610170565b82525050565b60008115159050919050565b6101c0816101ab565b82525050565b60006040820190506101db600083018561019c565b6101e860208301846101b7565b9392505050565b60805160a0516101796102126000396000609e01526000600f01526101796000f3fe6080604052610151471461009c577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1660656040516100529061012e565b60006040518083038185875af1925050503d806000811461008f576040519150601f19603f3d011682016040523d82523d6000602084013e610094565b606091505b5050506100d5565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16ff5b005b600081905092915050565b7f9f678cca00000000000000000000000000000000000000000000000000000000600082015250565b60006101186004836100d7565b9150610123826100e2565b600482019050919050565b60006101398261010b565b915081905091905056fea26469706673582212208f094eb57682c27f678c08cf065a2df5b481a1c1e9514fcefff5890dd9318c1264736f6c63430008130033";
        // bytes memory helperCodeOptimised = hex"60a06040526040516101cd3803806101cd83398101604081905261002291610073565b6001600160a01b0381166080526040805160c08101909152608880825260009190610145602083013990508160008060046020850182855af1506000806084602485016000855af1505050506100a3565b60006020828403121561008557600080fd5b81516001600160a01b038116811461009c57600080fd5b9392505050565b608051608a6100bb600039600060060152608a6000f3fe60806040527f00000000000000000000000000000000000000000000000000000000000000004761015114801560385760018114604e57005b639f678cca600052600080600460006065865af1005b60028201fffea264697066735822122094051177adeb476a8b09a3e964e7bb31a6b6b738872403536ff18951fec66c6a64736f6c634300081300337159a618deecedd400000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000441c0e1a100000000000000000000000000000000000000000000000000000000";
        // console.logBytes(helperCode);
        // bytes memory helperCalldata = abi.encodePacked(helperCode, _puzzle);
        // console.logBytes(helperCalldata);
        assembly {
            calldatacopy(0x00, 0x10, 0x14)
            mstore(add(helperCode, 0x3ab), mload(0x00))
            let helperAddr := create(0, add(helperCode, 0x20), mload(helperCode))
            pop(call(gas(), helperAddr, 0, 0, 0, 0, 0))
            // puzzle.leak()
            pop(call(gas(), mload(0x00), 0, add(selectoors, 0x24), 4, 0, 0))
            // warming up puzzle + 2
            // pop(call(gas(), 0x037EDA3AdB1198021A9B2e88C22B464Fd38DB3f5, 1, 0, 0, 0, 0))
            // zip
            pop(call(gas(), mload(0x00), 0, add(selectoors, 0x28), 4, 0, 0))
            // creep
            pop(call(98000, mload(0x00), 0, add(selectoors, 0x2c), 4, 0, 0))
            // torch
            pop(call(gas(), mload(0x00), 0, add(selectoors, 0x30), 293, 0, 0))
            // spread
            pop(call(gas(), mload(0x00), 0, add(selectoors, 0x155), 260, 0, 0))
            // open
            pop(call(gas(), mload(0x00), 0, add(selectoors, 0x259), 196, 0, 0))
        }
    }
}


// contract Helper {
//     address immutable puzzle;
//     constructor(address _puzzle) payable {
//         puzzle = _puzzle;
//         bytes memory data = hex"7159a618deecedd400000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000441c0e1a100000000000000000000000000000000000000000000000000000000";
//         address puzz = _puzzle;
//         assembly {
//             // operate
//             pop(call(gas(), puzz, 0, add(data, 0x20), 4, 0, 0))
//             // lock()
//             pop(call(gas(), puzz, 0, add(data, 0x24), 132, 0, 0))
//         }
//     }

//     fallback() external payable {
//         // bytes memory data = hex"9f678cca";
//         address puzz = puzzle;
//         assembly {
//             switch eq(selfbalance(), 337)
//             case 0 {
//                 mstore(0x00, 0x9f678cca)
//                 pop(call(gas(), puzz, 101, 0x00, 4, 0, 0))
//             }
//             case 1 {
//                 // warming puzzle + 2
//                 selfdestruct(add(puzz, 2))
//             }
//         }
//     }
// }

        // friends[0] = payable(0x416e59DaCfDb5D457304115bBFb9089531D873B7);
        // uint160(bytes20(0xC817dD2a5daA8f790677e399170c92AabD044b57))
        // 0xC817dD2a5daA8f790677e399170c92AabD044b57 -> not implicitly convertible to uint256, but
        // 0x00C817dD2a5daA8f790677e399170c92AabD044b57 is. Strange.
        // friendsCutBps[0] = 0x00C817dD2a5daA8f790677e399170c92AabD044b57;
        // friendsCutBps[1] = 150;
        // friendsCutBps[2] = 75;

        // address sol = solution;
        // bytes4 fnSig = hex"19ae45e4";
        // assembly {
        //     mstore(0x00, fnSig)
        //     switch eq(selfbalance(), 337)
        //     case 0 {
        //         pop(
        //             call(gas(), caller(), 101, 0x00, 4, 0x20, 0x20)
        //         )
        //     }
        //     case 1 {
        //         selfdestruct(sol)
        //     }
        // }